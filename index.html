<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Subscription Analyzer</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; }
textarea { width: 100%; height: 120px; margin-bottom: 10px; font-family: monospace; }
button { padding: 10px 20px; font-size: 16px; margin-bottom: 20px; }
table { border-collapse: collapse; margin-bottom: 30px; width: 100%; }
th, td { border: 1px solid #333; padding: 5px 10px; text-align: left; }
th { background-color: #f2f2f2; }
.header { background-color:#d9edf7; font-weight:bold; text-align:center; }
.subheader { background-color:#fcf8e3; font-weight:bold; text-align:center; }
.claimed { background-color:#d4edda; color:#155724; }
.missed { background-color:#f8d7da; color:#721c24; }
</style>
</head>
<body>

<h2>Subscription Analyzer</h2>

<label>Paste Purchase Data (tab-separated):</label>
<textarea id="purchaseData"></textarea>

<label>Paste Claim Data (3-line repeating pattern per claim):</label>
<textarea id="claimData"></textarea>

<button onclick="analyze()">Analyze</button>

<div id="results"></div>

<script>
const PACKS = {
  7.00: {name:"Sub Pack 07", sc:0.50, gc:2000},
  30.00:{name:"Sub Pack 30", sc:2.00, gc:10000},
  90.00:{name:"Sub Pack 90", sc:5.50, gc:40000}
};
const SUB_DURATION_DAYS = 7;

// Format Date as YYYY-MM-DD HH:MM
function formatDate(date){
  const pad=n=>n.toString().padStart(2,"0");
  return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
}

// Parse purchases
function parsePurchases(text){
  const lines = text.trim().split('\n').map(l=>l.trim()).filter(l=>l);
  const purchases=[];
  for(let i=0;i<lines.length;i++){
    if(lines[i].toLowerCase().includes("sub_pack")){
      const prev = i>0 ? lines[i-1] : null;
      if(!prev) continue;
      const ts = new Date(prev.split("\t")[0]);
      const nextLine = (i+1)<lines.length ? lines[i+1] : lines[i];
      const amtMatch = nextLine.match(/\d+(\.\d+)?/);
      if(!amtMatch) continue;
      const amt = parseFloat(amtMatch[0]);
      if(PACKS[amt]) purchases.push({purchase_ts:ts, pack_amount:amt, pack_name:PACKS[amt].name});
    }
  }
  return purchases;
}

// Parse claims
function parseClaims(text){
  const lines = text.trim().split('\n').map(l=>l.trim()).filter(l=>l);
  const claims = [];
  for(let i=0;i<lines.length;i+=3){
    const scgcLine = lines[i].split("\t");
    if(scgcLine.length<2) continue;
    const sc=parseFloat(scgcLine[0]);
    const gc=parseInt(scgcLine[1]);
    const dateLine = lines[i+2];
    if(!dateLine) continue;
    const dateMatch = dateLine.match(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/);
    if(!dateMatch) continue;
    const ts = new Date(dateMatch[0]);
    let pack_name = null;
    for(let amt in PACKS){
      if(PACKS[amt].sc === sc && PACKS[amt].gc === gc){
        pack_name = PACKS[amt].name;
        break;
      }
    }
    if(pack_name) claims.push({claim_ts:ts, sc, gc, pack_name});
  }
  return claims;
}

// Compute merged intervals
function computeIntervals(purchases){
  const intervals = [];
  for(let amt in PACKS){
    const packName = PACKS[amt].name;
    let packPurchases = purchases.filter(p=>p.pack_amount==parseFloat(amt)).sort((a,b)=>a.purchase_ts-b.purchase_ts);
    let currentInterval = null;

    for(let p of packPurchases){
      const start = new Date(p.purchase_ts);

      // Compute Day1 → Day7 end for this purchase
      let day1End = new Date(start);
      if(start.getHours()<8) day1End.setHours(8,0,0,0);
      else { day1End.setDate(day1End.getDate()+1); day1End.setHours(8,0,0,0);}
      let purchaseEnd = new Date(day1End);
      purchaseEnd.setDate(purchaseEnd.getDate() + SUB_DURATION_DAYS -1);

      if(!currentInterval){
        currentInterval = {pack_name:packName, start_ts:start, end_ts:purchaseEnd};
      } else if(start <= currentInterval.end_ts){
        // extend the current interval
        if(purchaseEnd > currentInterval.end_ts) currentInterval.end_ts = purchaseEnd;
      } else {
        intervals.push(currentInterval);
        currentInterval = {pack_name:packName, start_ts:start, end_ts:purchaseEnd};
      }
    }

    if(currentInterval) intervals.push(currentInterval);
  }
  return intervals.sort((a,b)=>a.start_ts-b.start_ts);
}

// Compute Day windows
function computeDayWindows(interval){
  const windows = [];
  let day1End = new Date(interval.start_ts);
  if(interval.start_ts.getHours()<8) day1End.setHours(8,0,0,0);
  else { day1End.setDate(day1End.getDate()+1); day1End.setHours(8,0,0,0);}
  windows.push({day_label:"Day1", start:interval.start_ts, end:day1End});
  let prevEnd = new Date(day1End);
  while(prevEnd < interval.end_ts){
    const dayStart = new Date(prevEnd);
    const dayEnd = new Date(dayStart);
    dayEnd.setDate(dayEnd.getDate()+1);
    windows.push({day_label:`Day${windows.length+1}`, start:dayStart, end:dayEnd});
    prevEnd = dayEnd;
  }
  return windows;
}

// Map claims to days
function mapClaims(interval, claims){
  const windows = computeDayWindows(interval);
  const results = [];
  for(let w of windows){
    let claimFound = false;
    for(let c of claims.filter(cl=>cl.pack_name===interval.pack_name)){
      if(c.claim_ts >= w.start && c.claim_ts < w.end){
        results.push({day_label:w.day_label, start:w.start, end:w.end, status:formatDate(c.claim_ts)});
        claimFound = true;
        break;
      }
    }
    if(!claimFound) results.push({day_label:w.day_label, start:w.start, end:w.end, status:"Missed"});
  }
  return results;
}

// Create table
function createTable(interval, dayResults){
  const table = document.createElement("table");
  // Header
  const header = table.insertRow();
  const th = document.createElement("th"); th.colSpan=1; th.className="header"; th.innerText=interval.pack_name; header.appendChild(th);
  // Empty row under header
  const emptyRow = table.insertRow(); emptyRow.insertCell().innerText="";
  // Total days
  const totalRow = table.insertRow();
  const totalCell = totalRow.insertCell(); totalCell.innerText = `Total: ${dayResults.length} day${dayResults.length>1?'s':''}`; totalCell.style.backgroundColor="#d1ecf1"; totalCell.style.fontWeight="bold";
  // Start/end row
  const seRow = table.insertRow();
  seRow.insertCell().innerText = `Start: ${formatDate(interval.start_ts)} | End: ${formatDate(interval.end_ts)}`;
  // Subheader
  const subHeader = table.insertRow();
  const cell = subHeader.insertCell(); cell.innerText="Day Range | Status"; subHeader.className="subheader";
  // Day rows
  for(let d of dayResults){
    const row = table.insertRow();
    const cell = row.insertCell();
    cell.innerText = `${formatDate(d.start)} → ${formatDate(d.end)}  ${d.status}`;
    if(d.status !== "Missed") cell.className="claimed";
    else cell.className="missed";
  }
  return table;
}

// Main
function analyze(){
  const purchases = parsePurchases(document.getElementById("purchaseData").value);
  const claims = parseClaims(document.getElementById("claimData").value);
  const resultsDiv = document.getElementById("results");
  resultsDiv.innerHTML="";
  const intervals = computeIntervals(purchases);
  for(let interval of intervals){
    const dayResults = mapClaims(interval, claims);
    resultsDiv.appendChild(createTable(interval, dayResults));
  }
}
</script>

</body>
</html>
