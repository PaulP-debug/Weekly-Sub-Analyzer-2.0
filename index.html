<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Subscription Analyzer</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  textarea { width: 100%; height: 120px; margin-bottom: 10px; font-family: monospace; }
  button { padding: 10px 20px; font-size: 16px; margin-bottom: 20px; }
  table { border-collapse: collapse; margin-bottom: 30px; width: 100%; }
  th, td { border: 1px solid #333; padding: 5px 10px; text-align: left; }
  th { background-color: #f2f2f2; }
  .header { background-color: #d9edf7; font-weight: bold; text-align: center; }
  .subheader { background-color: #fcf8e3; font-weight: bold; text-align: center; }
  .claimed { background-color: #d4edda; color: #155724; }
  .missed { background-color: #f8d7da; color: #721c24; }
  .future { background-color: #e2e3e5; color: #6c757d; }
</style>
</head>
<body>

<h2>Subscription Analyzer</h2>

<label>Paste Purchase Data (7-column table, tab-separated):</label>
<textarea id="purchaseData"></textarea>

<label>Paste Claim Data (3-line repeating pattern per claim):</label>
<textarea id="claimData"></textarea>

<button onclick="analyze()">Analyze</button>

<div id="results"></div>

<script>
const PACKS = {
  7.00: {name: "Sub Pack 07", sc: 0.50, gc: 2000},
  30.00: {name: "Sub Pack 30", sc: 2.00, gc: 10000},
  90.00: {name: "Sub Pack 90", sc: 5.50, gc: 40000}
};
const SUB_DURATION_DAYS = 7;

// Format Date as YYYY-MM-DD HH:MM
function formatDate(date){
  if(!date) return "";
  const pad = n => n.toString().padStart(2,"0");
  const y = date.getFullYear();
  const m = pad(date.getMonth()+1);
  const d = pad(date.getDate());
  const h = pad(date.getHours());
  const min = pad(date.getMinutes());
  return `${y}-${m}-${d} ${h}:${min}`;
}

// Parse purchases
function parsePurchases(text){
  const lines = text.trim().split('\n').map(l=>l.trim()).filter(l=>l);
  const purchases=[];
  for(let i=0;i<lines.length;i++){
    if(lines[i].toLowerCase().includes("sub_pack")){
      const prev = i>0 ? lines[i-1] : null;
      if(!prev) continue;
      const ts = new Date(prev.split("\t")[0]);
      const nextLine = (i+1)<lines.length ? lines[i+1] : lines[i];
      const amtMatch = nextLine.match(/\d+(\.\d+)?/);
      if(!amtMatch) continue;
      const amt = parseFloat(amtMatch[0]);
      if(PACKS[amt]) purchases.push({purchase_ts: ts, pack_amount: amt, pack_name: PACKS[amt].name});
    }
  }
  return purchases;
}

// Parse claims
function parseClaims(text){
  const lines = text.trim().split('\n').map(l=>l.trim()).filter(l=>l);
  const claims = [];
  for(let i=0; i<lines.length; i+=3){
    const scgcLine = lines[i].split("\t");
    if(scgcLine.length < 2) continue;
    const sc = parseFloat(scgcLine[0]);
    const gc = parseInt(scgcLine[1]);
    const dateLine = lines[i+2];
    if(!dateLine) continue;
    const dateMatch = dateLine.match(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/);
    if(!dateMatch) continue;
    const ts = new Date(dateMatch[0]);
    let pack_name = null;
    for(let amt in PACKS){
      if(PACKS[amt].sc === sc && PACKS[amt].gc === gc){
        pack_name = PACKS[amt].name;
        break;
      }
    }
    if(pack_name) claims.push({claim_ts: ts, sc, gc, pack_name});
  }
  return claims;
}

// Compute Day1â€“Day7 windows
function computeDayWindows(purchase_ts){
  const windows=[];
  const resetHour = 8;
  
  // Apply 08:00 cutoff for purchase
  const start = new Date(purchase_ts);
  if(start.getHours() < resetHour){
    start.setDate(start.getDate() -1);
  }
  
  let prev = new Date(start);
  for(let i=1;i<=SUB_DURATION_DAYS;i++){
    const dayStart = new Date(prev);
    const dayEnd = new Date(dayStart);
    dayEnd.setDate(dayEnd.getDate() +1);
    dayEnd.setHours(resetHour,0,0,0);
    windows.push({day_label:`Day${i}`, start:dayStart, end:dayEnd});
    prev = dayEnd;
  }
  return windows;
}

// Map all claims to windows
function mapClaims(interval, claims){
  const windows = computeDayWindows(interval.purchase_ts);
  const results=[];
  
  for(let w of windows){
    let status="Missed";
    for(let claim of claims.filter(c=>c.pack_name===interval.pack_name)){
      const claimTime = new Date(claim.claim_ts);
      // 08:00 cutoff for claim
      if(claimTime.getHours()<8){
        claimTime.setDate(claimTime.getDate()-1);
      }
      if(claimTime>=w.start && claimTime<w.end){
        status="Claimed";
        break;
      }
    }
    // Future detection
    const now = new Date();
    if(w.start > now) status="Future";
    results.push({day_label:w.day_label, status});
  }
  
  return results;
}

// Create HTML table
function createTable(interval, dayResults){
  const table = document.createElement("table");

  const header = table.insertRow();
  const th = document.createElement("th"); 
  th.colSpan = 1; 
  th.className = "header"; 
  th.innerText = interval.pack_name; 
  header.appendChild(th);

  const pRow = table.insertRow();
  pRow.insertCell().innerText = `Backend: ${formatDate(interval.purchase_ts)}`;

  const subHeader = table.insertRow();
  const cell1 = subHeader.insertCell();
  cell1.innerText = "Backend";
  subHeader.className = "subheader";

  for(let d of dayResults){
    const row = table.insertRow();
    const cell = row.insertCell();
    cell.innerText = d.status;
    if(d.status==="Claimed") cell.className="claimed";
    else if(d.status==="Missed") cell.className="missed";
    else if(d.status==="Future") cell.className="future";
  }
  return table;
}

// Main analyzer
function analyze(){
  const purchases = parsePurchases(document.getElementById("purchaseData").value);
  const claims = parseClaims(document.getElementById("claimData").value);
  const resultsDiv = document.getElementById("results");
  resultsDiv.innerHTML="";
  const intervals = purchases.sort((a,b)=>a.purchase_ts-b.purchase_ts);
  for(let interval of intervals){
    const dayResults = mapClaims(interval, claims);
    resultsDiv.appendChild(createTable(interval, dayResults));
  }
}
</script>

</body>
</html>
